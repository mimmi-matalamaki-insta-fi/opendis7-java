/**
 * Copyright (c) 2008-2023, MOVES Institute, Naval Postgraduate School (NPS). All rights reserved.
 * This work is provided under a BSD-style open-source license, see project
 * <a href="https://savage.nps.edu/opendis7-java/license.html" target="_blank">license.html</a> and <a href="https://savage.nps.edu/opendis7-java/license.txt" target="_blank">license.txt</a>
 */
// header autogenerated using string template dis7javalicense.txt



package edu.nps.moves.dis7.pdus;

import java.util.*;
import java.io.*;
import edu.nps.moves.dis7.enumerations.*;

/**
 * An entity's munition (e.g., bomb, missile) information shall be represented by one or more Munition records. For each type or location of munition, this record shall specify the type, location, quantity and status of munitions that an entity contains. Section 6.2.60 
 * @see <a href="https://ieeexplore.ieee.org/document/6387564" target="_blank">IEEE Std 1278.1-2012, IEEE Standard for Distributed Interactive Simulation - Application Protocols</a> 
 */
public class Munition extends Object implements Serializable
{
   /**  This field shall identify the entity type of the munition. See section 6.2.30. */
   protected EntityType  munitionType = new EntityType(); 

   /** The station or launcher to which the munition is assigned. See Annex I */
   protected int station;

   /** The quantity remaining of this munition. */
   protected short quantity;

   /**  the status of the munition. It shall be represented by an 8-bit enumeration.  uid 327 */
   protected MunitionExpendableStatus munitionStatus = MunitionExpendableStatus.values()[0];

   /** zero-filled array of padding bits for byte alignment and consistent sizing of PDU data */
   protected byte padding = (byte)0;


/** Constructor creates and configures a new instance object */
 public Munition()
 {
 }

  /**
   * Returns size of this serialized (marshalled) object in bytes
   * @see <a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)" target="_blank">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
   * @return serialized size in bytes
   */
public int getMarshalledSize()
{
   int marshalSize = 0; 

   if (munitionType != null)
       marshalSize += munitionType.getMarshalledSize();
   marshalSize += 4;  // station
   marshalSize += 2;  // quantity
   if (munitionStatus != null)
       marshalSize += munitionStatus.getMarshalledSize();
   marshalSize += 1;  // padding

   return marshalSize;
}


/** Setter for {@link Munition#munitionType}
  * @param pMunitionType new value of interest
  * @return same object to permit progressive setters */
public Munition setMunitionType(EntityType pMunitionType)
{
    munitionType = pMunitionType;
    return this;
}
/** Getter for {@link Munition#munitionType}
  * @return value of interest */
public EntityType getMunitionType()
{
    return munitionType;
}


/** Setter for {@link Munition#station}
  * @param pStation new value of interest
  * @return same object to permit progressive setters */
public Munition setStation(int pStation)
{
    station = pStation;
    return this;
}
/** Getter for {@link Munition#station}
  * @return value of interest */
public int getStation()
{
    return station; 
}

/** Setter for {@link Munition#quantity}
  * @param pQuantity new value of interest
  * @return same object to permit progressive setters */
public Munition setQuantity(short pQuantity)
{
    quantity = pQuantity;
    return this;
}
/** Utility setter for {@link Munition#quantity}
  * @param pQuantity new value of interest
  * @return same object to permit progressive setters */
public Munition setQuantity(int pQuantity){
    quantity = (short) pQuantity;
    return this;
}
/** Getter for {@link Munition#quantity}
  * @return value of interest */
public short getQuantity()
{
    return quantity; 
}

/** Setter for {@link Munition#munitionStatus}
  * @param pMunitionStatus new value of interest
  * @return same object to permit progressive setters */
public Munition setMunitionStatus(MunitionExpendableStatus pMunitionStatus)
{
    munitionStatus = pMunitionStatus;
    return this;
}
/** Getter for {@link Munition#munitionStatus}
  * @return value of interest */
public MunitionExpendableStatus getMunitionStatus()
{
    return munitionStatus; 
}

/** Setter for {@link Munition#padding}
  * @param pPadding new value of interest
  * @return same object to permit progressive setters */
public Munition setPadding(byte pPadding)
{
    padding = pPadding;
    return this;
}
/** Utility setter for {@link Munition#padding}
  * @param pPadding new value of interest
  * @return same object to permit progressive setters */
public Munition setPadding(int pPadding){
    padding = (byte) pPadding;
    return this;
}
/** Getter for {@link Munition#padding}
  * @return value of interest */
public byte getPadding()
{
    return padding; 
}

/**
 * Serializes an object to a DataOutputStream.
 * @throws java.lang.Exception if something goes wrong
 * @see java.io.DataOutputStream
 * @param dos the OutputStream
 */
public void marshal(DataOutputStream dos) throws Exception
{
    try 
    {
       munitionType.marshal(dos);
       dos.writeInt(station);
       dos.writeShort(quantity);
       munitionStatus.marshal(dos);
       dos.writeByte(padding);
    }
    catch(Exception e)
    {
      System.err.println(e);
    }
}

/**
 * Deserializes an object from a DataInputStream.
 * @throws java.lang.Exception if something goes wrong
 * @see java.io.DataInputStream
 * @see <a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)" target="_blank">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
 * @param dis the InputStream
 * @return marshalled serialized size in bytes
 */
public int unmarshal(DataInputStream dis) throws Exception
{
    int uPosition = 0;
    try 
    {
        uPosition += munitionType.unmarshal(dis);
        station = dis.readInt();
        uPosition += 4;
        quantity = (short)dis.readUnsignedShort();
        uPosition += 2;
        munitionStatus = MunitionExpendableStatus.unmarshalEnum(dis);
        uPosition += munitionStatus.getMarshalledSize();
        padding = (byte)dis.readUnsignedByte();
        uPosition += 1;
    }
    catch(Exception e)
    { 
      System.err.println(e); 
    }
    return getMarshalledSize();
}

/**
 * Packs an object into the ByteBuffer.
 * @throws java.nio.BufferOverflowException if byteBuffer is too small
 * @throws java.nio.ReadOnlyBufferException if byteBuffer is read only
 * @see java.nio.ByteBuffer
 * @param byteBuffer The ByteBuffer at the position to begin writing
 * @throws Exception ByteBuffer-generated exception
 */
public void marshal(java.nio.ByteBuffer byteBuffer) throws Exception
{
   munitionType.marshal(byteBuffer);
   byteBuffer.putInt( (int)station);
   byteBuffer.putShort( (short)quantity);
   munitionStatus.marshal(byteBuffer);
   byteBuffer.put( (byte)padding);
}

/**
 * Unpacks a Pdu from the underlying data.
 * @throws java.nio.BufferUnderflowException if byteBuffer is too small
 * @see java.nio.ByteBuffer
 * @see <a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)" target="_blank">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
 * @param byteBuffer The ByteBuffer at the position to begin reading
 * @return marshalled serialized size in bytes
 * @throws Exception ByteBuffer-generated exception
 */
public int unmarshal(java.nio.ByteBuffer byteBuffer) throws Exception
{
    try
    {
        // attribute munitionType marked as not serialized
        munitionType.unmarshal(byteBuffer);
        // attribute station marked as not serialized
        station = byteBuffer.getInt();
        // attribute quantity marked as not serialized
        quantity = (short)(byteBuffer.getShort() & 0xFFFF);
        // attribute munitionStatus marked as not serialized
        munitionStatus = MunitionExpendableStatus.unmarshalEnum(byteBuffer);
        // attribute padding marked as not serialized
        padding = (byte)(byteBuffer.get() & 0xFF);
    }
    catch (java.nio.BufferUnderflowException bue)
    {
        System.err.println("*** buffer underflow error while unmarshalling " + this.getClass().getName());
    }
    return getMarshalledSize();
}

 /*
  * Override of default equals method.  Calls equalsImpl() for content comparison.
  */
@Override
 public boolean equals(Object obj)
 {
    if(this == obj)
      return true;

    if(obj == null)
       return false;

    if(!getClass().isAssignableFrom(obj.getClass())) //if(getClass() != obj.getClass())
        return false;

    return equalsImpl(obj);
 }

 /**
  * Compare all fields that contribute to the state, ignoring
  * transient and static fields, for <code>this</code> and the supplied object
  * @param obj the object to compare to
  * @return true if the objects are equal, false otherwise.
  */
 public boolean equalsImpl(Object obj)
 {
     final Munition rhs = (Munition)obj;

     if( ! Objects.equals(munitionType, rhs.munitionType) ) return false;
     if( ! (station == rhs.station)) return false;
     if( ! (quantity == rhs.quantity)) return false;
     if( ! (munitionStatus == rhs.munitionStatus)) return false;
     if( ! (padding == rhs.padding)) return false;
    return true;
 }

 @Override
 public String toString()
 {
    StringBuilder sb  = new StringBuilder();
    StringBuilder sb2 = new StringBuilder();
    sb.append(getClass().getSimpleName());
    sb.append(" munitionType:").append(munitionType); // writeOneToString
    sb.append(" station:").append(station); // writeOneToString
    sb.append(" quantity:").append(quantity); // writeOneToString
    sb.append(" munitionStatus:").append(munitionStatus); // writeOneToString
    sb.append(" padding:").append(padding); // writeOneToString

   return sb.toString();
 }

 @Override
 public int hashCode()
 {
	 return Objects.hash(this.munitionType,
	                     this.station,
	                     this.quantity,
	                     this.munitionStatus,
	                     this.padding);
 }
} // end of class
